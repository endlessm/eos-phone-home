#!/usr/bin/env python3
#
# This script sends anonymous messages to Endless in order for us to know how
# many EOS systems are used across the globe. Note that this does not send any
# identifiable user data - it only transmits the originally installed operating
# system version, the OS version, machine vendor, the product name, and whether
# the more detailed OS metrics system is enabled (for sanity-checking the two
# systems). GeoIP is used to find the approximate location of the system, but
# beyond this server logs are neither used for association nor are they kept
# beyond what is needed for IT administration support.
#
# The first type of message is an "activation", which is sent only once per
# system. In addition to the above data, it contains the machine serial number
# number and a hash of the MAC address of the first non-removable ethernet
# or wireless network adapter, as some vendors do not set the serial number
# correctly/uniquely. As the serial and MAC hash is only sent once, it cannot
# be used for tracking purposes over time.
#
# The second type of message is a "ping", which is sent at most once per 24
# hours. In addition to the above data, it contains a counter of how many
# times the machine has successfully pinged the Endless server before, which
# allows us to count the number of active installations over time.
#
# Thanks for Canonical for their description and implementation of this
# technique, respectively:
#  - http://theravingrick.blogspot.co.uk/2010/08/can-we-count-users-without-uniquely.html
#  - https://launchpad.net/canonical-poke
#
# (C) 2016,2017 Endless Mobile Inc.
# License: GPL v2 or later
#
# https://home.endlessm.com/v1/activate
#
# Arguments in the JSON PUT string will be:
#  image (the image name, from the xattr on /sysroot)
#  release (from /etc/os-release)
#  vendor (from DMI / device tree)
#  product (from DMI / device tree)
#  serial (from DMI / Endless mfgdata)
#  live (true if this is a live USB, false if not)
#  dualboot (true if this is a dual boot installation, false if not)
#  mac_hash (ADLER32 hash of first non-removable ethernet or wireless
#            interface MAC address)
#
# https://home.endlessm.com/v1/ping
#
# Arguments in the JSON PUT string will be:
#  image (the image name, from the xattr on /sysroot)
#  release (from /etc/os-release)
#  vendor (from DMI / device tree)
#  product (from DMI / device tree)
#  count (from counter file, incremented each successful ping)
#  dualboot (true if this is a dual boot installation, false if not)
#  metrics_enabled (true if metrics are being collected and uploaded)
#  metrics_environment ("production", "dev" or "test")

import argparse
import collections
import configparser
import logging
import glob
import os
import re
import subprocess
import time
import zlib

import requests

log = logging.getLogger(__name__)


ProductInfo = collections.namedtuple('ProductInfo',
                                     ['vendor', 'product', 'serial'])


class PhoneHome(object):
    STATE_DIRECTORY = "/var/lib/eos-phone-home"

    ACTIVATION_ENDPOINT = os.getenv('EOS_PHONE_HOME_ACTIVATE_URL',
                                    "https://home.endlessm.com/v1/activate")
    ACTIVATION_VARIABLES = ('dualboot', 'live', 'image', 'release', 'vendor',
                            'product', 'serial', 'mac_hash')

    PING_ENDPOINT = os.getenv('EOS_PHONE_HOME_PING_URL',
                              "https://home.endlessm.com/v1/ping")
    PING_VARIABLES = ('dualboot', 'image', 'release', 'vendor', 'product',
                      'count', 'metrics_enabled', 'metrics_environment')

    # variables which should be replaced with "unknown" rather
    # than omitted if the get function returns None
    MANDATORY_STRINGS = ('image', 'vendor', 'product', 'release', 'serial',
                         'metrics_environment')

    def __init__(self, is_debug, force):
        self._debug = is_debug
        self._force = force
        self._variables = {}

        self._activated_path = os.path.join(self.STATE_DIRECTORY, 'activated')
        self._count_path = os.path.join(self.STATE_DIRECTORY, 'count')

    def _get_dt_info(self):
        '''Note that this is not a regular file: it contains multiple
        vendor/product lines that are NUL-delimited.'''
        # XXX: Used for testing due to the odd spec
        # path = 'test_data/compatible'
        path = '/proc/device-tree/compatible'

        try:
            with open(path, 'r') as dt_file:
                dt_data = dt_file.read().split('\0')[0].split(',')

            log.debug("DT data: %s", dt_data)
            return dt_data
        except Exception:
            log.exception('Failed to read %s', path)
            return None

    def _read_text(self, path):
        '''Reads stripped text from path, logging & squashing errors.'''
        try:
            with open(path, 'r') as f:
                return f.read().strip()
        except Exception:
            log.exception('Failed to read %s', path)
            return None

    def _get_product_info(self):
        try:
            dmi_dir = '/sys/class/dmi/id'
            if os.path.isdir(dmi_dir):
                vendor = self._read_text(os.path.join(dmi_dir, 'sys_vendor'))
                product = self._read_text(os.path.join(dmi_dir, 'product_name'))
                serial = self._read_text(os.path.join(dmi_dir, 'product_serial'))
            else:
                dt_fields = self._lookup_or_get_variable('dt_info')
                if dt_fields:
                    vendor = dt_fields[0]
                    product = dt_fields[1]
                else:
                    vendor = None
                    product = None

                ssn_path = '/sys/class/endless_mfgdata/entries/SSN'
                serial = self._read_text(ssn_path)

            product_info = ProductInfo(vendor, product, serial)
            log.info(" - Found product info: %s", product_info)
            return product_info
        except Exception:
            log.exception("Unable to get product info!")
            return ProductInfo(None, None, None)

    def _get_vendor(self):
        return self._lookup_or_get_variable('product_info').vendor

    def _get_product(self):
        return self._lookup_or_get_variable('product_info').product

    def _get_serial(self):
        return self._lookup_or_get_variable('product_info').serial

    def _get_image(self):
        image = None

        for path in ['/sysroot', '/']:
            try:
                image = subprocess.check_output(['attr', '-q', '-g',
                                                 'eos-image-version', path])
                image = image.decode(errors='replace').strip()

                log.info(" - Image from %s: %s", path, image)

                return image
            except subprocess.CalledProcessError:
                log.info("Unable to get image name from %s", path)

        return None

    def _get_metrics(self):
        permissions_file = '/etc/metrics/eos-metrics-permissions.conf'

        enabled = False
        uploading_enabled = False
        environment = 'unknown'

        try:
            config = configparser.ConfigParser()
            config.read(permissions_file)
            enabled = config['global'].getboolean('enabled', enabled)
            uploading_enabled = config['global'].getboolean('uploading_enabled',
                                                            uploading_enabled)
            environment = config['global'].get('environment', environment)
        except Exception:
            log.exception("Unable to read %s, assuming fallback values.",
                          permissions_file)

        environment = environment[:16]

        Metrics = collections.namedtuple('Metrics', 'enabled environment')
        return Metrics(enabled and uploading_enabled, environment)

    def _get_metrics_enabled(self):
        enabled = self._lookup_or_get_variable('metrics').enabled
        log.info(' - Metrics enabled: %s', enabled)
        return enabled

    def _get_metrics_environment(self):
        environment = self._lookup_or_get_variable('metrics').environment
        log.info(' - Metrics environment: %s', environment)
        return environment

    def _get_release(self):
        try:
            release_data = None
            with open('/etc/os-release') as release_file:
                release_data = release_file.read()

            for release_item in release_data.splitlines():
                release_item = release_item.strip()

                key, value = release_item.split('=', 1)
                if key == 'VERSION':
                    log.info(' - Found version key')

                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]

                    release = value.strip()

                    log.info(' - Release: %s', release)

                    return release

        except Exception:
            log.exception("Unable to get release name!")

        return None

    def _get_cmdline(self):
        with open('/proc/cmdline', 'r') as command_line_file:
            command_line = command_line_file.read().strip()

        log.info(" - Cmdline: %s", command_line)
        return command_line

    def _get_live(self):
        live = False

        command_line = self._lookup_or_get_variable('cmdline')

        if re.search(r'\bendless.live_boot\b', command_line):
            log.info(" - Found live marker. Marking as live image.")
            live = True

        return live

    def _get_dualboot(self):
        command_line = self._lookup_or_get_variable('cmdline')
        live = self._lookup_or_get_variable('live')

        # In theory, one could be image-booted without endless.live_boot from a
        # USB if you go in and delete the 'live' flag file, but this is not a
        # supported configuration.
        if not live and re.search(r'\bendless.image.device\b', command_line):
            log.info(" - Found endless.image.device marker and no live marker."
                     " Marking as dual-boot.")
            return True

        return False

    def _get_mac_hash(self):
        try:
            eth_ifaces = []
            wlan_ifaces = []

            for iface in glob.glob('/sys/class/net/*'):
                # skip virtual interfaces
                device = os.path.join(iface, 'device')
                if not os.path.exists(device):
                    continue

                # skip USB devices
                subsystem = os.readlink(os.path.join(device, 'subsystem'))
                if os.path.basename(subsystem) == 'usb':
                    continue

                # build separate list of wireless interfaces
                if os.path.exists(os.path.join(iface, 'wireless')):
                    wlan_ifaces.append(iface)
                else:
                    eth_ifaces.append(iface)

            # prefer the fixed interfaces if there are any, wireless if not
            if eth_ifaces:
                ifaces = eth_ifaces
            elif wlan_ifaces:
                ifaces = wlan_ifaces
            else:
                return None

            devs = {}
            for iface in ifaces:
                with open(os.path.join(iface, 'address')) as mac_file:
                    mac = mac_file.read().strip().lower()
                dev = os.path.basename(iface)
                devs[mac] = dev

            mac = sorted(devs.keys())[0]
            mac_hash = zlib.adler32(mac.encode('utf-8'))

            log.info(" - Selected dev %s address %s", devs[mac], mac)
            log.info(" - Found MAC hash: %u", mac_hash)

            return mac_hash
        except Exception:
            log.exception("Unable to get mac_hash!")

            return None

    def _get_count(self):
        count = 0

        try:
            with open(self._count_path, 'r') as count_file:
                count_data = count_file.read()

            if count_data:
                count = int(count_data.strip())
        except FileNotFoundError:
            pass
        except Exception:
            log.exception("Unable to get count!")
            return 0

        log.info(" - Count: %d", count)
        return count

    def _set_count(self, count):
        try:
            with open(self._count_path, 'w') as count_file:
                count_file.write("%d" % count)

            self._variables['count'] = count

            log.info(" - Updated count: %d", count)
        except Exception:
            log.exception("Unable to set count!")

            raise

    def _lookup_or_get_variable(self, name):
        if name not in self._variables:
            log.info("Getting variable: %s", name)
            var = getattr(self, '_get_' + name)()

            if name in self.MANDATORY_STRINGS and not var:
                var = "unknown"

            self._variables[name] = var

        return self._variables[name]

    def _send_to_server(self, endpoint, variables):
        request = {}
        for name in variables:
            val = self._lookup_or_get_variable(name)
            if val is not None:
                request[name] = val

        log.info("Request data: %s", request)
        log.info("Sending to server (%s)...", endpoint)

        if self._debug:
            log.info("Debugging turned on so nothing sent to server!")
            return True

        try:
            resp = requests.put(endpoint, json=request)
            resp.raise_for_status()
        except Exception:
            log.warning("Sending failed!", exc_info=True)
            return False

        try:
            response = resp.json()
        except ValueError:
            # TODO: json.JSONDecodeError when we ship Python >= 3.5
            log.warning("Failed to parse response: %r", resp.content, exc_info=True)
            return False

        log.info('Response: %s', response)

        if response.get('success') is True:
            log.info("Server returned success message!")
            return True
        else:
            log.info("Server failed to process the data: %s", response)
            return False

    def _need_to_activate(self):
        return not os.path.exists(self._activated_path)

    def _do_activate(self):
        if self._send_to_server(self.ACTIVATION_ENDPOINT,
                                self.ACTIVATION_VARIABLES):
            # We're done, mark us activated
            with open(self._activated_path, 'w'):
                pass

            log.info("Activated!")
        else:
            log.warning("Could not send activation data to server!")

            return False

        return True

    def _need_to_ping(self):
        if self._lookup_or_get_variable('live'):
            log.info("Not sending ping from live system.")
            return False

        try:
            count_time = os.path.getmtime(self._count_path)
        except FileNotFoundError:
            log.info("%s doesn't exist yet", self._count_path)
            return True

        count_age = time.time() - count_time
        log.info("Count age: %s", count_age)

        if count_age < 0:
            log.info("Clock has gone backwards? Resetting time so we will "
                     "ping again in 24 hours.")

            count = self._lookup_or_get_variable('count')
            self._set_count(count)

            return False

        # we aim to ping daily
        DAY_IN_SECONDS = 60 * 60 * 24
        return count_age >= DAY_IN_SECONDS

    def _do_ping(self):
        if self._send_to_server(self.PING_ENDPOINT, self.PING_VARIABLES):
            if self._debug:
                log.info("Debugging turned on so not incrementing count.")
            else:
                # increment the counter upon successful ping only
                count = self._lookup_or_get_variable('count')
                self._set_count(count + 1)

            log.info("Pinged!")
        else:
            log.warning("Could not send ping to server!")

            return False

        return True

    def run(self, exit_on_server_error):
        if not os.path.isdir(self.STATE_DIRECTORY):
            log.critical("State folder (%s) not found! Exiting!",
                         self.STATE_DIRECTORY)
            exit(1)

        if not os.access(self.STATE_DIRECTORY, os.W_OK):
            log.critical("State folder (%s) not writable! Exiting!",
                         self.STATE_DIRECTORY)
            exit(1)

        success = True

        try:
            if self._force or self._need_to_activate():
                log.info("Activation needed.")
                if not self._do_activate():
                    success = False
            else:
                log.info("Already activated!")

            if self._force or self._need_to_ping():
                log.info("Ping needed.")
                if not self._do_ping():
                    success = False
            else:
                log.info("Ping not due yet.")
        except Exception:
            log.exception("Unhandled exception:")
            exit(1)

        if not success and exit_on_server_error:
            exit(1)


def main():
    p = argparse.ArgumentParser()
    p.add_argument('--debug', action='store_true',
                   help='verbose output; disables any actual phoning home')
    p.add_argument('--force', action='store_true',
                   help='always collect data (implies --debug)')
    p.add_argument('--exit-on-server-error', action='store_true',
                   help='exit with a non-0 status if activation and/or ping '
                        "can't be sent to the server")

    args = p.parse_args()
    is_debug = args.debug or args.force
    if is_debug:
        log.info("Debugging turned on!")
        level = logging.DEBUG
    else:
        level = logging.INFO
    logging.basicConfig(level=level)
    PhoneHome(is_debug, args.force).run(args.exit_on_server_error)


if __name__ == '__main__':
    main()
